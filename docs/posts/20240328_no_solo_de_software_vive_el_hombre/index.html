<!DOCTYPE html>
<html lang="es-AR">

<head>
	
	<title>No solo de software vive el hombre | mi Blog | iyaki</title>
	<meta charset="utf-8">
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<meta name="description" content="Leyes y principios para una mejor gestión de proyectos de software">
	<meta name="author" content="Ivan Yakimovicz">
	<meta name="keywords" content="Ivan Yakimovicz, Ivan Yaki, iyaki">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<link rel="icon" type="image/svg+xml" href="/images/logo.svg">
	
		<link href="/css/posts.css" rel="stylesheet">
	
	
  
	<link rel="canonical" href="https://iyaki.ar/posts/20240328_no_solo_de_software_vive_el_hombre/">
	
	<script>!function(t,e){var o,p,n,i;e.__SV||(window.posthog=e,e._i=[],e.init=function(r,s,a){function c(t,e){var o=e.split(".");2==o.length&&(t=t[o[0]],e=o[1]),t[e]=function(){t.push([e].concat(Array.prototype.slice.call(arguments,0)))}}(n=t.createElement("script")).type="text/javascript",n.async=!0,n.src=s.api_host+"/static/array.js",(i=t.getElementsByTagName("script")[0]).parentNode.insertBefore(n,i);var u=e;for(void 0!==a?u=e[a]=[]:a="posthog",u.people=u.people||[],u.toString=function(t){var e="posthog";return"posthog"!==a&&(e+="."+a),t||(e+=" (stub)"),e},u.people.toString=function(){return u.toString(1)+".people (stub)"},o="capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags".split(" "),p=0;p<o.length;p++)c(u,o[p]);e._i.push([r,s,a])},e.__SV=1)}(document,window.posthog||[]),posthog.init("phc_GiyRIzw94jjfJLj7Wm2KozJ1LnuFPY81cc3HymGjqd4",{api_host:"https://app.posthog.com"})</script>
</head>

<body>
	<header class="header-panel blog-header">
	<div class="blog-header__title">
		<a href="/" title="Inicio ">
			<img src="/images/logo.svg" alt="Logo de mi web, unos anteojos 3D de cartón blanco con film azul y rojo" title="Allons-y!" async>
		</a>
		<a href="/blog">
			<h1>mi<br>Blog</h1>
		</a>
	</div>
</header>
<main class="main-panel main-content">
	<aside aria-label="newsletter-form">
		<style>
.newsletter-form{border:.15em solid var(--box-border-color);padding:.5em 3em 1em}
.newsletter-form,.newsletter-form header h2,.newsletter-form header p{text-align:center}
.newsletter-form button,.newsletter-form input{border:1px solid var(--box-border-color);border-radius:3px;font-size:var(--base-font-size);margin:.1em auto;padding:.25em 1em}
.newsletter-form input{background-color:transparent}
.newsletter-form button{background-color:var(--blog-header-background-color);color:#f5f5f5;cursor:pointer}
.newsletter-form button:hover{box-shadow:3px 3px 3px var(--blog-header-background-color);text-shadow:#fff 1px 1px .5em;translate:-2px -2px}
.newsletter-form button:active{box-shadow:none;translate:none}		</style>
		<article class="newsletter-form">
			<header>
				<h2>No te vuelvas a perder un post!</h2>
				<p>Subscribite a la newsletter de mi Blog</p>
			</header>
			<form action="https://simple-newsletter.com/subscriptions/">
				<input type="hidden" name="uri" value="https://iyaki.ar/posts/feed.xml">
				<label>
					<span lang="en">E-mail</span>:
					<input type="email" name="email" required>
				</label>
				<button type="submit">Subscribirme</button>
			</form>
		</article>
	</aside>
	<article>
<h1>No solo de software vive el hombre</h1>
<p>Usar las herramientas adecuadas para el trabajo adecuado, saber utilizarlas y darles el mantenimiento necesario para que sigan funcionando son formas importantes de aumentar nuestra productividad. Pero existe algo con un impacto mucho más profundo y de mayor magnitud: Tomar las decisiones que más nos acercarán a nuestros resultados deseados. Porque uno puede ser extremadamente rápido para construir un auto, pero si lo que se necesitaba era un barco, de poco servirá todo el esfuerzo que se invierta.</p>
<p>En este aspecto hay dos puntos elementales que nos ayudarán a alcanzar el mayor impacto posible mediante nuestro trabajo.</p>
<p>El primero es conocer cuál es el resultado deseado, en este sentido, por lo general, cuanto más contexto e información tengamos sobre el problema que buscamos solucionar, mejor preparados estaremos para brindar una solución.</p>
<p>El segundo aspecto relevante es poder predecir, de la manera más acertada posible, las consecuencias de nuestras acciones. Para esto podemos optar por opciones poco ortodoxas como el tarot, la bola de cristal o la lectura de la borra del café; o centrarnos en aprovechar lo que otros han estudiado al respecto en el pasado y sus conclusiones. Conclusiones que en muchos casos se han recopilado en leyes, teorías y principios ampliamente conocidos en el ámbito de la gestión y la tecnología.</p>
<p>En este artículo nos centraremos en estas últimas.</p>
<p>Por eso hoy, dejo un breve resumen de las que considero más útiles a la hora de avanzar sobre un proyecto como colaborador individual o como parte de su <span lang="en">management</span>.</p>
<h2 id="pareto"><a href="#pareto">Principio de Pareto o Regla del 80/20</a></h2>
<p>Durante el siglo XIX el economista italiano Vilfredo Pareto observó que <b>aproximadamente el 80% de los efectos proviene del 20% de las causas</b>.</p>
<p>En el contexto de proyectos de software, este principio cobra una relevancia significativa. Al aplicarlo, nos damos cuenta de que el 80% del valor agregado proviene del 20% de las características o funcionalidades implementadas.</p>
<p>Y entonces, ¿por qué esto es tan relevante para nosotros?</p>
<p>Porque nos ayuda a priorizar.</p>
<p>Si sabemos qué pequeña parte de nuestro trabajo es responsable de la mayoría de los resultados, podemos concentrarnos en eso primero.</p>
<p>Ya sea que estemos trabajando en solitario o en equipo, el Principio de Pareto nos da una hoja de ruta inteligente para maximizar nuestra eficiencia y lograr mejores resultados.</p>
<h2 id="carga-cognitiva"><a href="#carga-cognitiva">Carga cognitiva</a></h2>
<p>La carga cognitiva no es un principio como tal, pero sí un concepto que, si tenemos en cuenta, puede ayudarnos a nosotros y a nuestros compañeros a obtener mejores resultados.</p>
<p>La carga cognitiva <b>se refiere a la cantidad de esfuerzo mental requerido para realizar una tarea o procesar información</b>.</p>
<p>Imaginemos que estamos trabajando en un proyecto de software y debemos recordar todos los detalles sobre cómo funciona cada parte del código que se está escribiendo. Bueno, esa es la carga cognitiva en acción.<br>
Cuanto más complicado sea el proyecto, más trabajo mental habrá que hacer para mantener todo en orden.</p>
<p>A la hora de programar existen múltiples maneras de disminuir la carga cognitiva que una pieza de código fuente requiere. A mí, en particular, me agradan bastante las sugerencias de <a href="https://franiglesias.github.io/calisthenics-1/" target="_blank"><i lang="en">Object Calisthenics</i></a>.</p>
<h2 id="context-switching" lang="en"><a href="#context-switching">Context Switching</a></h2>
<p>Otro concepto que, a pesar de no tratarse de una ley o principio, puede impactar significativamente en nuestra productividad.</p>
<p><span lang="en">Context switching</span> <b>se refiere al proceso de cambiar nuestra atención y enfoque de una tarea a otra</b>. Este cambio constante de contexto puede ser perjudicial para nuestra productividad, ya que requerimos tiempo y energía para ajustarnos a la nueva tarea.</p>
<p>Y peor aún, aunque la interrupción fuese breve, volver a <a href="https://www.kenneth-truyers.net/2015/10/05/programming-in-the-zone/" target="_blank" hreflang="en"><i lang="en">the zone</i></a> o <a href="https://github.blog/2024-01-22-how-to-get-in-the-flow-while-coding-and-why-its-important/" target="_blank" hreflang="en"><i lang="en">the flow</i></a> puede tomarnos <a href="https://contextkeeper.io/blog/the-real-cost-of-an-interruption-and-context-switching/" target="_blank" hreflang="en">hasta 15 minutos</a>.</p>
<h2 id="ockham"><a href="#ockham">Principio de parsimonia o Navaja de Ockham</a></h2>
<p>El Principio de Parsimonia, también conocido como la Navaja de Ockham, es un principio filosófico que sugiere que, <b>entre varias explicaciones posibles para un fenómeno, la más simple suele ser la correcta</b>. Este principio, propuesto por el filósofo y teólogo Guillermo de Ockham en el siglo XIV, aboga por no multiplicar las entidades innecesariamente.</p>
<p>Entonces, en el mundo del desarrollo de software, esto significa que cuando nos encontramos con un problema a resolver (un bug, una nueva funcionalidad a implementar, un desafío a nivel de arquitectura, etc.), deberíamos intentar encontrar la solución más sencilla posible. En lugar de enredarnos con soluciones complejas que pueden generar más problemas, deberíamos seguir el camino más simple y directo.</p>
<p>Dentro del mundo de la programación, esto se encuentra también muy relacionado con los principios <a href="https://enterprisecraftsmanship.com/posts/yagni-revisited/" target="_blank" hreflang="en"><abbr title="You Aren't Gonna Need It" lang="en">YAGNI</abbr></a> y <a href="https://enterprisecraftsmanship.com/posts/kiss-revisited/" target="_blank" hreflang="en"><abbr title="Keep it Simple, Stupid" lang="en">KISS</abbr></a>.</p>
<h2 id="conway"><a href="#conway">Ley de Conway</a></h2>
<p>La Ley de Conway viene a recordarnos lo importante que es la comunicación en el desarrollo de software, formulada por el programador Melvin Conway en 1968, establece que <b>las organizaciones que diseñan sistemas están inevitablemente limitadas a producir diseños que sean réplicas de la estructura de comunicación de sus propias organizaciones</b>.</p>
<p>He visto muchas veces artículos y explicaciones que se centran en cómo un equipo con poca organización y falta de comunicación producirá software de baja calidad y que, probablemente, no resuelva necesidades reales. Pero a mí me resulta mucho más interesante tener en cuenta esta ley a la hora de diseñar sistemas y definir su arquitectura.</p>
<p>El impacto de la ley de Conway en la arquitectura de software es muy significativo y es algo que he podido comprobar de primera mano. Hace algunos años y en medio del hype por los microservicios, en la empresa donde trabajaba, nos propusimos a, para sorpresa de nadie, migrar a una arquitectura de microservicios. Los beneficios de esta arquitectura son bien conocidos, y entre ellos destacan:</p>
<ol>
<li>Mejor tolerancia a fallos, al facilitar desacoplar los servicios, permitiendo que una pieza de software fallé sin afectar a las demás.</li>
<li>Agnosticismo tecnológico, cada microservicio puede desarrollarse con las tecnologías que considere más apropiadas para lograr su cometido.</li>
<li>Mayor independencia a la hora de evolucionar y desplegar cada servicio al poder hacerlo de manera individual.</li>
<li>Reusabilidad entre áreas de negocio, si partes de la lógica de negocio se repiten entre distintos procesos y áreas, es posible reutilizar los servicios ya desarrollados.</li>
<li>Permite la experimentación y la evolución rápida, al poder ser desarrollados sin comprometer al resto del sistema.</li>
</ol>
<p>Pero nunca llegamos a beneficiarnos de ellos y es que:</p>
<ol>
<li>Nuestras reglas de negocio, aunque bien definidas, eran bastante complejas y la forma en que el equipo las concibe hace que estén fuertemente acopladas entre sí; por lo que, incluso desarrollando diferentes aplicativos, el nivel de dependencia entre ellos impedía una mayor resiliencia ante fallos de un componente.</li>
<li>Todo nuestro equipo tenía experiencia en los mismos lenguajes de programación, por lo que las posibles tecnologías a utilizar eran bastante limitadas.</li>
<li>Al haber dependencias tan fuertes entre las distintas reglas de negocio, cualquier cambio terminaba afectando múltiples componentes.</li>
<li>Nuestras reglas de negocio, aunque complejas, se mantenían dentro de un alcance bastante acotado, por lo que la reutilización de servicios era muy poco probable.</li>
<li>Al tener un equipo conformado, principalmente, por desarrolladores <span lang="en">Junior</span>, la experimentación resultaba casi nula.</li>
</ol>
<p>Y, para empeorar, las cosas, los integrantes del equipo siempre había trabajado de manera muy cercana entre ellos, por lo que no existía un <i lang="en">ownership</i> claro sobre procesos o módulos que permitieran la independencia necesaria para desacoplar las distintas piezas de software. Resultando en que los intentos de separar servicios y comunicarlos solo generara confusión y frustración.</p>
<p>Este es un claro ejemplo de cómo un equipo que tenía la capacidad técnica para desarrollar microservicios falló en hacerlo por razones meramente organizativas y comunicacionales.</p>
<p>Para poder implementar exitosamente una arquitectura de microservicios, primero deberíamos haber comenzado por cambiar la forma en que trabajábamos. Armar múltiples equipos (idealmente uno por microservicio) con un alcance y objetivos claros, capacitar a los desarrolladores en nuevas tecnologías, probablemente contratar más colaboradores, etc.</p>
<p>Por suerte, esta migración fue lanzada como una prueba piloto, y notamos todos estas fricciones antes de que se volvieran un problema.</p>
<p>Así, de común acuerdo con el resto del equipo, decidimos volver al esquema monolítico con el que trabajábamos hasta entonces y centrar nuestros esfuerzos en mejorar la estructura y modularidad de nuestra aplicación, en lugar de intentar separar todo de manera artificial y forzada en distintos servicios independientes.</p>
<h2 id="parkinson"><a href="#parkinson">Ley de Parkinson</a></h2>
<p>En 1957 Cyril Northcote Parkinson enunció: <b>el trabajo se expande hasta llenar el tiempo disponible para que se termine</b>.</p>
<p>Al realizar la gestión de un proyecto, ya sea como colaboradores individuales, estimando tareas que deberán realizarse o realizando planificaciones de alto nivel, como <span lang="en">Project Manager</span>, siempre es buena idea tener en cuenta esta ley.</p>
<p>Según nos advierte, aumentar “por las dudas” el tiempo que se planifica para dedicar a una cierta tarea puede no ser la mejor idea, ya que terminaremos consumiendo ese tiempo en detalles superfluos y probablemente innecesarios (este es un buen punto en el que aplicar el Principio de Pareto para decidir cuando detenerse) en lugar de aprovechar ese tiempo en adelantar otras tareas que puedan aportar un mayor valor real.</p>
<h2 id="brooks"><a href="#brooks">Ley de Brooks</a></h2>
<p>Fred Brooks, en su libro <em lang="en">The Mythical Man-Month</em> publicado en 1975, afirma: <b>añadir más efectivos a un proyecto de software en retraso, lo retrasará más</b>.</p>
<p>Esta es especialmente relevante para los roles de <span lang="en">Management</span> y Liderazgo en proyectos de desarrollo de software, ya que antaño era una práctica muy normal el intentar resolver los problemas de un proyecto mediante la adición de más y más colaboradores.</p>
<p>El problema es que, lejos de de generar resultados más velozmente, se produce el efecto contrario; donde la entrega de valor se retrasa aún más, debido a que la comunicación se complejiza de manera exponencial a medida que se agregan personas y se requiere tiempo adicional para capacitar a estas nuevas incorporaciones y transferirles todo el contexto necesario.</p>
<h2 id="hofstadter"><a href="#hofstadter">Ley de Hofstadter</a></h2>
<p>Esta ley describe la dificultad de estimar el tiempo que llevará completar tareas de gran complejidad acuñada por Douglas Hofstadter en su libro <em lang="en">Gödel, Escher, Bach:  an Eternal Golden Braid</em> afirma: <b>Siempre nos lleva más tiempo de lo esperado, incluso teniendo en cuenta la ley de Hofstadter</b>.</p>
<p>Sobre esta creo que no hay mucho que agregar, pero conocerla es una buena forma de recordar que la estimación de tareas siempre cuenta con su cuota de incertidumbre.</p>
<h2 id="ventanas-rotas"><a href="#ventanas-rotas">Teoría de las ventanas rotas</a></h2>
<p>Esta teoría proviene de la criminología. Introducida en un artículo de 1982 por los científicos sociales James Q. Wilson y George L. Kelling y popularizada en la década de 1990, sostiene que <b>los signos visibles de la delincuencia, el comportamiento antisocial y los disturbios civiles crean un entorno urbano que fomenta la delincuencia y el desorden, incluidos los delitos graves</b>; sugiriendo que los métodos policiales que se centran en atacar los delitos menores, como el vandalismo, la vagancia, el consumo de alcohol en público, el cruce incorrecto de peatones y la evasión de tarifas, ayudan a crear una atmósfera de orden y legalidad.</p>
<p>Esta idea es portada en 1999 al ámbito de la programación por Andy Hunt y Dave Thomas en su libro <em lang="en">The Pragmatic Programmer</em>, donde aplican el concepto de las ventanas rotas a la calidad de software.</p>
<p>En su libro, sugieren nunca dejas las <i>ventanas rotas</i> sin arreglar y repararlas en cuanto se las identifica. Evitando así esparcir malas prácticas al resto del código fuente.</p>
<p>Considero esto particularmente importante cuando un equipo cuenta con una gran cantidad de desarrolladores <span lang="en">Junior</span>, ya que es mediante el mismo código fuente sobre el que están trabajando que, día a día, siguen aprendiendo cómo programar. Sin embargo al ser una práctica que depende en gran medida de la cultura del equipo (y del área o la empresa donde esté trabajando ese equipo) puede ser un desafío notable implementar prácticas que fomenten la reparación constante de estas <i>ventanas rotas</i>.</p>
<h2 id="hanlon"><a href="#hanlon">Principio de Hanlon</a></h2>
<p>El Principio de Hanlon (o navaja de Hanlon) no trata de manera directa sobre productividad pero es una herramienta que puede ayudarnos a lograr mejores resultados cuando se trabaja en conjunto.</p>
<p>Este principio establece: <b>Nunca atribuyas a la maldad lo que se explica adecuadamente por la estupidez</b>.</p>
<p>Me gusta porque es simple y pragmático, y nos invita a darle a las personas el beneficio de la duda. Recordándonos que muchas veces un conflicto que estemos teniendo con otras personas puede ser producto, simplemente, de un malentendido.</p>
<h2>Redondeando</h2>
<p>Esas fueron la leyes, principios y conceptos que, a mi parecer, resultan mas útiles a la hora de participar en un proyecto software.</p>
<p>Espero que les puedan ser de utilidad también a ustedes.</p>
<p>Si quieren charlar sobre este o cualquier otro tema siempre pueden contactarme via <span lang="en">e-mail</span> o dejar un comentario (Me olvidé de avisar eso! Ahora hay una sección de comentarios al final de los <span lang="en">posts</span> 😁).</p>
<p lang="ua">До побаченія!</p>

</article>

	
	<script src="https://giscus.app/client.js" data-repo="iyaki/iyaki.github.io" data-repo-id="R_kgDOI1fGcg" data-category="Blogpost comments" data-category-id="DIC_kwDOI1fGcs4CdYrB" data-mapping="pathname" data-strict="1" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="top" data-theme="preferred_color_scheme" data-lang="es" data-loading="lazy" crossorigin="anonymous" async></script>

</main>
<aside class="third-panel">
	
</aside>

</body>
</html>
